/****************************************************************************
**
** Copyright (C) 2015 Stiftung Secure Information and
**                    Communication Technologies SIC and
**                    Graz University of Technology
** Contact: http://opensource.iaik.tugraz.at
**
**
** Commercial License Usage
** Licensees holding valid commercial licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and SIC. For further information
** contact us at http://opensource.iaik.tugraz.at.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3.0 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU General Public License version 3.0 requirements will be
** met: http://www.gnu.org/copyleft/gpl.html.
**
** This software is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with this software. If not, see http://www.gnu.org/licenses/.
**
**
****************************************************************************/

#include "ibe/bbkem.h"

int main(void) {
	byte key1[16], key2[16];
	bbkem_ciphertext cipher;
	const char *id = "cm0 in public";

	encapsulate_key(key1, &cipher, id);

	decapsulate_key(key2, &cipher, id);

	assert_bytearr_equal(key1, key2, 16, "key decapsulated correctly");

	bbkem_ciphertext var_cipher;
	byte var_key[16];

#if (BNCURVE == BN256)
#ifdef MONTGOMERY_ARITHMETIC
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 539 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 540 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 541 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 542 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 543 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 544 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 545 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 546 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 547 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 548 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 549 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 550 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 551 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 552 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 553 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	{0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
	0},
	{{0xEBB90DF3, 0x767FD2B7, 0x71DCE135, 0xC6601526, 0x61296178, 0xB174B17D, 0x43E5B0CD, 0x5F188502},
	{0x48ED0443, 0xA2DE7E79, 0x58838E34, 0x1DBD8DBD, 0x40330BAF, 0xBDADC2CE, 0x174624A4, 0x60571C6C},
	0}, };
		static const byte var_key_exp[] = {0xA6, 0xC1, 0xED, 0x7A, 0x08, 0x04, 0x7C, 0x08, 0x35, 0x00, 0x91, 0xB7, 0x93, 0x97, 0x4F, 0x24};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 554 key");
	}
#else
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xB6F8D938, 0x6AE1CF4C, 0xC9512D1A, 0x0743E170, 0xF0E19A85, 0x7CB8F2AD, 0xE0D486BA, 0x08931DF5},
	{0x761E60F1, 0xDDF04261, 0x9F9DB079, 0x2219D7D0, 0xF7934820, 0xA947BFEE, 0x6761A1A5, 0x02A91014},
	0},
	{{0xAF5B1C28, 0xC0C0A786, 0xEF1C1912, 0xF66BFD10, 0x7C14BCB9, 0x4A0AAE37, 0x3C6DF766, 0x2F1EA772},
	{0x2A15DB44, 0x5B902D27, 0x7EA5B135, 0x493292C1, 0x9195F6B6, 0xF18E667C, 0xE76EC43D, 0x690623A2},
	0}, };
		static const byte var_key_exp[] = {0x95, 0x09, 0x46, 0xE0, 0xE5, 0x7B, 0x23, 0xD1, 0x39, 0xAA, 0x0D, 0xAC, 0xFF, 0x98, 0xD3, 0xF3};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 1 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xBF24AC19, 0xF9ECC1FD, 0x9079A033, 0xCCEC7833, 0x4C3FE7F2, 0xD4101909, 0x0DEB96BF, 0x0CC4D110},
	{0xBB662DAD, 0x33E7B5D8, 0x6D5967CE, 0xF0A59354, 0x382DDC1F, 0xCB05BDAB, 0xEECA1A5D, 0xB33A722F},
	0},
	{{0xE4ECF836, 0x614ECA2B, 0x72D6C569, 0x60ABC8D3, 0x9C80E49B, 0x9196E80B, 0x53444B8D, 0x95D981A9},
	{0x788896E5, 0xCD40D1DC, 0x8841B352, 0xB51D9C69, 0x93AC8BCF, 0x41F95259, 0x5572AD89, 0x6D62B582},
	0}, };
		static const byte var_key_exp[] = {0x2C, 0x0F, 0xBA, 0x3C, 0x7F, 0x16, 0xB0, 0xF9, 0x0B, 0x10, 0x40, 0xEE, 0x23, 0xC3, 0x2A, 0xC5};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 2 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x3E7CA865, 0xA331F102, 0x4F27403A, 0xA42386D0, 0x702C7010, 0x87FCD2CF, 0x42204AE5, 0x0B1CDFA7},
	{0xE792F6F3, 0xBDBFFF76, 0xED7A5BCF, 0x63C3954B, 0xAB29B303, 0x8BB3D97B, 0x25D2D480, 0x8C45DF81},
	0},
	{{0xBE60DE7A, 0x4AE7C6C1, 0x66797CF0, 0xD63DDFA7, 0xB1D07F62, 0x7FDE6DA4, 0xB95E9C44, 0x71F70629},
	{0x4EB6E5FC, 0x88F2971F, 0xA589EC31, 0xE601D316, 0x29FCEE68, 0x84BA719C, 0xB39E7732, 0x934DFB4A},
	0}, };
		static const byte var_key_exp[] = {0xCF, 0xD1, 0xD5, 0xEA, 0x84, 0xF1, 0x7F, 0xE6, 0xBC, 0x03, 0x0A, 0x8C, 0x44, 0x9B, 0x5F, 0x4E};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 3 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x7C65B614, 0x52563429, 0xD57F5350, 0xA3EE61FF, 0x186DF469, 0xF4FC1266, 0x7C872A81, 0x894991D4},
	{0x56FD8F26, 0x181C0AA9, 0xE5CA109B, 0xEC4E5750, 0x3A137133, 0x94CCC4C4, 0x7ED9CAE8, 0x2CF5F2E8},
	0},
	{{0x79A5E5F9, 0x3DB0BD5E, 0x86A8EEAC, 0x4866E824, 0x55278038, 0xBD63E32E, 0x0F7CBD49, 0x4D842B66},
	{0xEBE7B6D5, 0xB0076F2E, 0xBB2F59AF, 0xD7C577C3, 0x0B6FF790, 0xC072F13C, 0xADF76858, 0x96CBCCEA},
	0}, };
		static const byte var_key_exp[] = {0x9B, 0x8D, 0xBB, 0x5C, 0xEE, 0x0A, 0x04, 0xBE, 0xB3, 0x2E, 0xF6, 0x42, 0x31, 0xE2, 0xBC, 0xAE};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 4 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x056D8AA3, 0xC4C341D8, 0x5E013942, 0xB207F52D, 0xC51BE61E, 0x9DBB3C1A, 0x7B749259, 0x4ACC8B6C},
	{0xC6E9C655, 0x23282DFB, 0x90393675, 0x3B1C2E3E, 0x9C76A75F, 0x43692A58, 0x9A41C2E4, 0xAEAFA3CF},
	0},
	{{0x7CBCA78D, 0x0F7764F2, 0xE3564C0A, 0x1518191D, 0xFCA5C250, 0x77F1E7A8, 0xF0269494, 0xAC821B91},
	{0xE3E28398, 0x667CD15B, 0x7D11DD38, 0x59B072C8, 0xDBD19EC9, 0x40E36793, 0x6C710932, 0x1802C746},
	0}, };
		static const byte var_key_exp[] = {0xF4, 0x55, 0x83, 0xEF, 0x38, 0x9F, 0x32, 0x64, 0x81, 0x6A, 0xCB, 0xDC, 0x34, 0x25, 0xC4, 0x85};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 5 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xD4421E2D, 0x4260C377, 0x62478553, 0xF57D8864, 0x879BAAA2, 0x6FBC140A, 0x20E0FCCF, 0x459C7012},
	{0xAE24AA2C, 0xA39FFD25, 0x1643C679, 0x2F4197D7, 0xD2BD154A, 0xB4027B03, 0x89EC52A8, 0x2C8CACBF},
	0},
	{{0xF44758DC, 0x71620543, 0x043D2E86, 0x0504F780, 0x4E13A8E6, 0x8198DE3F, 0xBE94FBBB, 0x20AF6963},
	{0xE2953A8B, 0xA5015FDF, 0x28CF10BB, 0xE8B83352, 0x3E5BC8C9, 0xA71E1B99, 0x8BCBCF71, 0x7E6F92C1},
	0}, };
		static const byte var_key_exp[] = {0x7F, 0xD7, 0x1F, 0x01, 0x00, 0xA5, 0x8B, 0x87, 0x6F, 0xE1, 0x08, 0xF8, 0xE7, 0x82, 0x1D, 0xC9};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 6 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x042092AE, 0x5B01A616, 0xE7CE0BD5, 0xE927DDEF, 0xB3BA1511, 0x8DF599AE, 0x5B544154, 0x89433E41},
	{0x329CC228, 0x456332F2, 0xEA18C833, 0xFD528F3E, 0x959ED9DA, 0x19C53540, 0x2D2431BC, 0xAE79A36B},
	0},
	{{0x1BF02E65, 0x0C5183A6, 0x8F9E668B, 0x6D4F7D15, 0xDCD8E794, 0xAC878192, 0x7D7BA2D9, 0x712C9F45},
	{0x9F525B53, 0x56ED61F1, 0xBFA823A1, 0x82F5200D, 0xB4BFE2A6, 0x805E2CF6, 0x5978AFC0, 0x43968BA5},
	0}, };
		static const byte var_key_exp[] = {0x1E, 0x2C, 0x34, 0x25, 0x23, 0x4C, 0x41, 0xBF, 0x2B, 0xFE, 0x99, 0x37, 0x35, 0x4F, 0x8E, 0x97};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 7 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x8BDBADFB, 0x9C8426E1, 0xE0D92C46, 0xE70E091A, 0x78300D55, 0x1C91B099, 0x20F7595C, 0x1DE22EC6},
	{0x0D52B806, 0x2756894D, 0x533D68EA, 0x94FA710E, 0xE5D89412, 0xC3B938CB, 0xE0B63918, 0x742243C1},
	0},
	{{0x457C6E3A, 0x105AEB4F, 0x9A6AC811, 0xD553BC9B, 0xFCB8A041, 0x1675BCF7, 0xBBB5D315, 0x13EB0185},
	{0x5318275A, 0x2FBA1737, 0x8A55EAF4, 0xF7E10E51, 0xA92D58EE, 0x3967977C, 0x31AD7164, 0x3F037813},
	0}, };
		static const byte var_key_exp[] = {0x75, 0xCE, 0xE7, 0xE2, 0x03, 0xFA, 0x9F, 0x6B, 0x7F, 0x13, 0x69, 0xD3, 0x84, 0xDE, 0x9F, 0xBE};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 8 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x1D3EE8CF, 0xEE1758CC, 0xD612528F, 0x15F428AC, 0xE4372A4C, 0xFC1BD429, 0x760672CB, 0x43BDC689},
	{0x760627DB, 0xC4823A2B, 0xA6A1DD0A, 0x9E83D3E4, 0xAE89E4B0, 0xACA5DB6A, 0x8CEFB5BD, 0xB7A86494},
	0},
	{{0x581539F2, 0xD1F1D218, 0x81DC2EF3, 0x3A675414, 0x424A541F, 0x01FFFA6D, 0xB2B4C9C2, 0x90EA3C7C},
	{0xE2AE3587, 0xD75CC47C, 0x46C8B97C, 0xD12B4D3D, 0x0ECC1BE8, 0xB82D1D52, 0xD5B0F190, 0xA59EADBB},
	0}, };
		static const byte var_key_exp[] = {0x25, 0x3C, 0xDF, 0x2E, 0x5E, 0xEB, 0x80, 0x35, 0xDE, 0x9E, 0x88, 0x86, 0x09, 0xE0, 0x72, 0x94};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 9 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xAB8A84C4, 0xD4079C79, 0x1D112061, 0xF7AA5743, 0xBE74101A, 0x46712E8C, 0xCCD85018, 0x7ECF086D},
	{0x2CCD4E14, 0x0CE8832C, 0x3BE15475, 0x05FEC21E, 0x10727505, 0x902BF120, 0x0EDDF23B, 0x793FD2E6},
	0},
	{{0xA66FD17C, 0x23032BAA, 0xA69DD7D7, 0x9E25E3C6, 0x10FD3299, 0x567DC753, 0x11EC354F, 0x98FBABB0},
	{0xC494D4EE, 0x0B4D6800, 0x526DFF2F, 0xD5E114CD, 0x9079F045, 0x5393B0D5, 0x38A1BFD0, 0xA3C1D293},
	0}, };
		static const byte var_key_exp[] = {0x17, 0xC3, 0x40, 0x83, 0x80, 0x1B, 0x30, 0xFE, 0x75, 0x5D, 0xCE, 0xC0, 0xA4, 0x1C, 0x03, 0x2E};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 10 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xAEB1E81F, 0xEAD4326F, 0x63F7FEA5, 0xCB266C7E, 0x7ACB0A21, 0xD6269E28, 0xC6B99EE5, 0x5B48AA8B},
	{0x28692DE7, 0xDF39303C, 0x0BF3ADEF, 0x90AD57F4, 0x085643BF, 0x0F874ADF, 0xE02F9626, 0x6A499502},
	0},
	{{0xEC775779, 0x7D5865AE, 0x3EB7859F, 0x792BF570, 0x991DB073, 0x328955BC, 0x819E24BF, 0x9A44D0E1},
	{0xD9EC36E5, 0x94649A14, 0x67910CDB, 0xAAA786FE, 0xFCF64196, 0xF432CC37, 0xE4B49B99, 0x1B208FB0},
	0}, };
		static const byte var_key_exp[] = {0x2E, 0x68, 0x81, 0x8F, 0x9A, 0x72, 0x2B, 0x51, 0xE1, 0xF9, 0xDF, 0x0F, 0x00, 0x36, 0xAC, 0x1A};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 11 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xB5A4F049, 0x77140CA4, 0x487216F2, 0xBDB29696, 0x102638D3, 0xDB7099C3, 0x4AA27409, 0xB5FAD3E2},
	{0x57316C99, 0xDF9A1657, 0x16FAB4A5, 0x7C3B39AB, 0x72937FD6, 0x48D85111, 0x7089EBE3, 0x2E5D2FB5},
	0},
	{{0x5DA11273, 0xBE2A96C5, 0x0C129299, 0x06949160, 0x122C5DBB, 0x1F6CFE21, 0xC818A15C, 0x2342304B},
	{0x60CEC581, 0x0400488F, 0x457DC130, 0xBDCE45A9, 0x22C767B8, 0x2506A360, 0x714F4CFA, 0xB2BD7C65},
	0}, };
		static const byte var_key_exp[] = {0x36, 0xAB, 0x88, 0x75, 0x42, 0x5D, 0x6C, 0x21, 0x9D, 0x19, 0x3F, 0xE0, 0x8D, 0x63, 0xBE, 0x20};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 12 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xFE89C520, 0x3D66F4CC, 0x53816AA6, 0x3A1BA62D, 0x300AA5ED, 0x847C224C, 0xE39DDD45, 0x9C379A59},
	{0x76287BCE, 0x2FCBA8CC, 0xD039F6D7, 0x6B75BE38, 0xD708EE6C, 0x83EAB14C, 0xB0F2779F, 0x15A315D6},
	0},
	{{0x123802D4, 0x873C54A0, 0xA6BB27B9, 0x60A65738, 0xF1580962, 0x7E218735, 0x9295467C, 0x093356BD},
	{0xC7A53343, 0x29112758, 0xD1D2EC44, 0xECB11CDC, 0x38CEDCE5, 0x539405D4, 0x238BFC2C, 0xA36E80A8},
	0}, };
		static const byte var_key_exp[] = {0x5C, 0x08, 0x4B, 0x39, 0x2A, 0x0A, 0xF1, 0x47, 0xF0, 0x11, 0x58, 0xDB, 0x4F, 0x58, 0xDC, 0xA3};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 13 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x8B60CBF8, 0x945A8130, 0xC77BFF61, 0xC7EBCADD, 0x5D93F6C6, 0x9F07E29A, 0x49B1F7AA, 0x59083D70},
	{0xA3A25639, 0xBFA66887, 0x67F897DF, 0x7002E9B5, 0x10D6A3E1, 0x0467B5CF, 0xF68AC765, 0x6D2EC2B2},
	0},
	{{0xFF41672B, 0x036460F2, 0x912A97A0, 0x4CD08C0D, 0x1F9595B8, 0x4FCD3CE6, 0x639FC4C4, 0x2C376AF0},
	{0x7FB2F72B, 0x515A4C71, 0x89A34840, 0x48789FF2, 0xDD43E1E3, 0x822B56B1, 0xE6FB6E42, 0x6CB2B2ED},
	0}, };
		static const byte var_key_exp[] = {0x5B, 0xCF, 0x94, 0xC8, 0xE0, 0x89, 0x45, 0xCB, 0xDE, 0xB3, 0x5A, 0x52, 0x76, 0x06, 0x38, 0x3D};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 14 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x0AAAA59E, 0xB57A19C8, 0xC5C0B945, 0x1D936846, 0xB49B43F1, 0x452B9859, 0x67EC9FFF, 0x71813159},
	{0x90053205, 0x0177445E, 0xA58F570B, 0x7FA5FB75, 0x8B35B624, 0xD9521DDE, 0x33CCEDAF, 0x9CDD50B1},
	0},
	{{0x68B1CF58, 0x1814F1EE, 0xCBFDE52D, 0xAD955FF5, 0x581FD1BF, 0x878FEC47, 0x1A238C4C, 0x937EFCB9},
	{0x002AA41C, 0xAD999968, 0x40DB15B1, 0x5692ED6B, 0x6AA2AA96, 0xD9B981F0, 0x14F5B2C8, 0x3CC36F27},
	0}, };
		static const byte var_key_exp[] = {0x0F, 0xEE, 0x51, 0x50, 0x08, 0x45, 0x87, 0x41, 0xE5, 0x46, 0x60, 0x0E, 0xBE, 0x3E, 0xA3, 0x93};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 15 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x4A63A7C6, 0x3F08DF6A, 0x0AF5D805, 0xE6235C59, 0x6C65932D, 0x0A0D11B6, 0x099CD3E0, 0x47AEAC3A},
	{0x2AECC8A0, 0xDFCD53FC, 0x09BAF9EC, 0xF157D9A2, 0xF10D5A3D, 0xBB488803, 0xAF649CCF, 0xA1493A54},
	0},
	{{0xFD162C21, 0x19F70E86, 0x16A65759, 0xCC22974E, 0x37967582, 0x6EB03093, 0x6B4676CC, 0x8A97D70C},
	{0x055355E1, 0xDA2F7404, 0x59EF502D, 0x5EC9408F, 0x8EC5A8CB, 0x52ECB94C, 0x5617D7BD, 0x22272AEB},
	0}, };
		static const byte var_key_exp[] = {0x54, 0x50, 0x69, 0xDD, 0x31, 0xC7, 0x5A, 0x2F, 0xEB, 0x6D, 0x25, 0x84, 0x14, 0x17, 0x60, 0x17};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 16 key");
	}

	return 0;
#endif
#elif (BNCURVE == BN254)
#ifdef MONTGOMERY_ARITHMETIC
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x1B2F70ED, 0xFAA7FF10, 0xAF4E4F30, 0x59A446B5, 0x4D44B5FD, 0x074A61CB, 0xDB97C6F6, 0x0A6C8F99},
	{0x63FE207A, 0xB1E6BC92, 0xF08C43DD, 0x75BEF647, 0x32552548, 0xD785A59A, 0xB923E6A3, 0x20807F8B},
	0},
	{{0xADB2B3E3, 0x125AA911, 0x3029E65A, 0x7CFF9E28, 0x9B4867CA, 0x7D4D77B3, 0xA6B8F41B, 0x1C0D9883},
	{0x562DE7AF, 0x66116E51, 0x48BC6BBC, 0xAB5ED31D, 0x2E9CE52B, 0x93C194C7, 0x3587D0C1, 0x007D3D5C},
	0}, };
		static const byte var_key_exp[] = {0xDF, 0x79, 0xD3, 0x3E, 0x2A, 0x40, 0x96, 0x50, 0xAB, 0x10, 0x1A, 0x1F, 0x3A, 0x10, 0x19, 0x56};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 947 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xCC8DEB56, 0x88C1BB28, 0x42FB9C68, 0x1B962D2D, 0x35D118FD, 0x36FA27C3, 0x5CB86E2C, 0x22B668ED},
	{0xF678014D, 0xA9D552DF, 0xD06556E5, 0xB4723292, 0x5D986F10, 0x317BDE11, 0xDC145201, 0x0D02A666},
	0},
	{{0x28976D4C, 0xF7788506, 0xD6638CD7, 0xFB82C51E, 0xC6723C5A, 0x76F54F71, 0xB981D2E5, 0x23DAC49B},
	{0x05DB2FFF, 0xDF65C124, 0xDC7159E8, 0x929E1F5A, 0x340D198B, 0xC5B545A4, 0xAEE647D5, 0x136446CB},
	0}, };
		static const byte var_key_exp[] = {0xA5, 0xF4, 0x82, 0x72, 0x64, 0x26, 0x2C, 0xCF, 0x3C, 0x72, 0xC8, 0xA0, 0xD8, 0xF5, 0x4B, 0x07};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 948 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xFEBE3B60, 0xC8B92A49, 0xBDC79A79, 0x3DA6569C, 0x8078C6C4, 0x21A92A9B, 0xA1A206DE, 0x1BE01851},
	{0xA6DCCA20, 0xCA1D2BE5, 0x27B42B0A, 0x8BF0069A, 0x454C81A1, 0xA421C309, 0x2207C912, 0x18C0F679},
	0},
	{{0x25316217, 0x8A5CA955, 0x6FC81F03, 0xAFC73DD7, 0x14445C09, 0x60E91F87, 0x7773706D, 0x07C43E02},
	{0xBCB93A34, 0x801BD69E, 0x3A17975D, 0xDED62995, 0x261564A3, 0x6E41AA47, 0x78E6789F, 0x163F8E9A},
	0}, };
		static const byte var_key_exp[] = {0x4E, 0xDF, 0x15, 0x7B, 0x02, 0xA5, 0x2B, 0x20, 0xF1, 0x11, 0xD4, 0x56, 0x74, 0x33, 0x63, 0x21};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 949 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x0ED9EB2E, 0x89B6F8F1, 0x3B5F3F57, 0xCCF5FD7E, 0x755EF513, 0x777802D0, 0x92024E8A, 0x1D309EB8},
	{0x993B8F5D, 0x1D266863, 0xD678AF8D, 0x7F11BB6C, 0x6CD9ADB6, 0xB2EF2092, 0x36990ABE, 0x0151C466},
	0},
	{{0x229BCC4F, 0x94AB5D53, 0x997FE432, 0x08DB74D3, 0x37EAF696, 0x453C64ED, 0x163B0C03, 0x088EA060},
	{0xA557352C, 0xF25368FD, 0x7E90ED64, 0xB290F7BB, 0x18B0CC06, 0x61DA5239, 0x0B8E5764, 0x19DD2937},
	0}, };
		static const byte var_key_exp[] = {0xED, 0xB8, 0xDD, 0x7C, 0x55, 0xB1, 0xEC, 0x03, 0x92, 0x01, 0x5F, 0x72, 0x86, 0x74, 0x3B, 0x19};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 950 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x51208D4F, 0xA40A1CB9, 0x3989D1FB, 0x527BF8BA, 0x82B079CF, 0x437E5707, 0xAB390F9F, 0x1AF685A1},
	{0xACAAC1C9, 0x7A61EA57, 0x12C78A89, 0xC27BB527, 0x29035ADF, 0x07B6C4B3, 0x76A47EE2, 0x062F2759},
	0},
	{{0x3ABC677C, 0x5B1BDDA3, 0xC33C59D0, 0x5A3FE91C, 0x8B345A25, 0xD2A2AC8F, 0xF4673461, 0x152C9832},
	{0x907A9184, 0xC0497510, 0x6C139970, 0xEF5F44F0, 0x6D6CD4E0, 0xF5AA147D, 0x203D288A, 0x0D3B5B06},
	0}, };
		static const byte var_key_exp[] = {0x2B, 0x1B, 0x62, 0x83, 0x56, 0x25, 0x7F, 0x14, 0xC2, 0xC9, 0x1C, 0xC8, 0x6A, 0xA0, 0x7C, 0xB9};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 951 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xF874A343, 0x31BDC6AB, 0x433A54AC, 0xFB522DF0, 0x4584A64A, 0xEEE5EA3C, 0xC55F9AD1, 0x0AFE2363},
	{0x5AF3F9F0, 0x200B484B, 0xF3E02534, 0x453D00BA, 0xB6471046, 0xC9DC3A49, 0xEF4E36B3, 0x04C6755B},
	0},
	{{0x42A07DFD, 0x3B3E2177, 0x253B73EC, 0x3BFB4AEB, 0x48A61386, 0x69C4B0EE, 0x8927F937, 0x184A3D32},
	{0x233F7144, 0xAAE3D9AA, 0x983B4A39, 0x91BFE414, 0x72A366F5, 0x96509A37, 0xA373F0BD, 0x08116378},
	0}, };
		static const byte var_key_exp[] = {0x5A, 0xCC, 0x06, 0xD0, 0x06, 0x2C, 0xA9, 0xE0, 0x2C, 0x61, 0xEA, 0x7D, 0xC1, 0xC5, 0x23, 0x2A};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 952 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x3D253AD6, 0x6594CAD2, 0xC12EEECA, 0xFC5B9250, 0x68E1208C, 0x8161FC40, 0x1C6E9F6D, 0x18817CBA},
	{0xC4D8D124, 0x6883E69F, 0xE07704B9, 0xD6B68AF2, 0xA583D0FA, 0xBD91441A, 0x2122839B, 0x05932D87},
	0},
	{{0xD6CCE958, 0x91A4CC9D, 0xD5E66C7F, 0x5770176A, 0xA01AEBB9, 0xE79FE86D, 0x3301C3F2, 0x1580EDB1},
	{0xCA440215, 0x038F92C5, 0x6E098B0F, 0x2C373925, 0xA4F86E5F, 0xC3BAB9B0, 0xAE10E0DB, 0x1E9D4D25},
	0}, };
		static const byte var_key_exp[] = {0x5F, 0xD8, 0xAB, 0x4C, 0xCF, 0x46, 0x17, 0x33, 0xC5, 0xE7, 0x43, 0xD9, 0x1A, 0x36, 0x1E, 0x7A};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 953 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x6AC0C144, 0x8D3FA7AD, 0x474D217B, 0x9122C45B, 0x89CFC9A2, 0x9F26BFF4, 0xEE274DFD, 0x152E1C32},
	{0x8ED6FBEF, 0x7A95EF2C, 0xB04C27B1, 0x7427CF93, 0xD9453875, 0x9CED1A9F, 0x7590CE93, 0x153EBCAE},
	0},
	{{0x5FDFA2BB, 0x20474EE7, 0xC2782513, 0x73A31A36, 0x1AE60C3A, 0xBE5D4E3B, 0x11A5CB3A, 0x2370EDF6},
	{0xD8C8D1FA, 0x9F81EA97, 0x772473C6, 0x1C366762, 0x13F9884C, 0x3E514F5A, 0xD61F505F, 0x22487B6C},
	0}, };
		static const byte var_key_exp[] = {0x82, 0xC9, 0x95, 0x5E, 0xC2, 0x42, 0x77, 0x9C, 0x26, 0x8F, 0xF0, 0x0F, 0xFF, 0xD6, 0xC4, 0x96};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 954 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xF6C84434, 0xA70FF973, 0xD573CFAA, 0x41560799, 0x1ACE702C, 0x527F9BFF, 0xB06E07F2, 0x20A5C420},
	{0x946B489A, 0x39134213, 0x0FBF6303, 0x9AF703CC, 0x8A306F6F, 0x6415EB17, 0x56CCA6F2, 0x07799C15},
	0},
	{{0xFC4ACD33, 0x686B1AA7, 0xA63F980E, 0x7B30FFAD, 0x577D0361, 0x710BF1C3, 0x3AA5950C, 0x0F647CD5},
	{0x23C12FB7, 0xCB20F1A8, 0x4BBE6288, 0x634718C5, 0xD5F3696B, 0x82B6E646, 0x74670EDD, 0x1C822734},
	0}, };
		static const byte var_key_exp[] = {0xDF, 0xA8, 0x2B, 0x6C, 0x8A, 0xF7, 0x56, 0x8F, 0x4C, 0xA8, 0x55, 0xFA, 0x32, 0xFA, 0xC0, 0xD0};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 955 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x9BBA83A6, 0xAA4D3CBD, 0xE969CD4E, 0x771337E1, 0xDF2F8CC2, 0xB77F721D, 0xD7A9113C, 0x05AD0C5D},
	{0xE05080A4, 0x2A74FA1B, 0xE28E95DB, 0xB2B3860A, 0x982D647E, 0xE5D5DD2A, 0xFFEBE7CB, 0x24E195FD},
	0},
	{{0xE9FB941E, 0x343A5605, 0xABA0B60E, 0x3E40775F, 0xB5002120, 0x385EF599, 0x3D1B304B, 0x05E84D6A},
	{0x81483498, 0xCFEB034E, 0xE57AB27F, 0x93FCBF3D, 0xF987C9EC, 0xB4035D31, 0x0356D20D, 0x0D38F993},
	0}, };
		static const byte var_key_exp[] = {0x97, 0x2C, 0x09, 0x03, 0x4F, 0x18, 0xEC, 0x99, 0x87, 0x88, 0x1A, 0xC8, 0x85, 0x37, 0x5C, 0x41};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 956 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x086881D6, 0x838323C2, 0x90F69368, 0xC0B9DAA1, 0x273AA9EA, 0xC2D42A9B, 0xFCC9C474, 0x024CDB55},
	{0x64A27211, 0xC98C1195, 0xBD9ED81C, 0xFE18FF29, 0x74C5DC90, 0xC8F0805D, 0x30BE052D, 0x1ED6AA42},
	0},
	{{0x4AA5C214, 0xE77D5F4D, 0x1209D891, 0x8D651389, 0xAD1C671F, 0x1A939C9E, 0xE4A6A752, 0x0CAF89AE},
	{0xF1D03277, 0xB7508931, 0xB123821E, 0xC2243D97, 0x3F11048D, 0x69876400, 0xF6B22690, 0x087CF483},
	0}, };
		static const byte var_key_exp[] = {0xED, 0xC7, 0xDF, 0xA7, 0x90, 0x12, 0xFD, 0x2E, 0x5A, 0x82, 0x24, 0xC7, 0x24, 0xB1, 0xD9, 0x39};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 957 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x5C820223, 0xBA0B8E45, 0xED190C5B, 0xE8FEB89E, 0x2CD24152, 0xAA7206C8, 0x1A629A73, 0x0ABD6F88},
	{0x2F1CDE3C, 0x9563A7E7, 0xEC6A3FFA, 0x617FD57A, 0xEE10C1B4, 0x4E4873ED, 0x6AAF28D6, 0x0BC92FB3},
	0},
	{{0xD36B2D05, 0x2F6C3756, 0x7FAD64AE, 0x44242A28, 0x6728A371, 0x8655E54D, 0x5FBBBC77, 0x24E596A2},
	{0x1E7DB610, 0x1E48A03C, 0xEE437490, 0x4F27D920, 0x286AC594, 0xD675E314, 0x27F92F57, 0x1D3CD9E7},
	0}, };
		static const byte var_key_exp[] = {0xF0, 0x2E, 0x02, 0x90, 0xE2, 0x1B, 0xF8, 0x14, 0x26, 0x49, 0xF5, 0xAF, 0xAB, 0x04, 0x21, 0xF5};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 958 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xA73CEA3A, 0x3BC86F87, 0x76D667BA, 0x7A445700, 0x1797CBD6, 0x735FB175, 0x2749FB6C, 0x186B8792},
	{0x83C77279, 0xE2390C4C, 0xA463F093, 0xC1B320DF, 0x210F8331, 0xFF9DD82F, 0x4E20E3A4, 0x17B4D157},
	0},
	{{0x690A109D, 0x8497FF5E, 0x23165ED8, 0x97CC95F4, 0x84B149FF, 0xC51E24A3, 0x43FE0F1F, 0x01FB84DC},
	{0x4F08039E, 0x2EDF418E, 0x1823FF48, 0xFAD8AA48, 0x79DEE6D2, 0x95BE112F, 0x1A39F7C5, 0x04004B09},
	0}, };
		static const byte var_key_exp[] = {0x83, 0xC0, 0xAA, 0xDE, 0x00, 0x46, 0xFB, 0x12, 0x42, 0xA1, 0x8B, 0x51, 0xDF, 0xF9, 0xAA, 0xC9};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 959 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x7721DA52, 0x04017820, 0x423B72D5, 0x8485A185, 0x60BCB434, 0x7A2CC7F7, 0x337EBC92, 0x10F914FF},
	{0x4E435654, 0x0703005F, 0xF1ADE8C6, 0xAD726995, 0x063A949B, 0x0BCC3855, 0x93FC3674, 0x0E2226CE},
	0},
	{{0xF628AA40, 0x32FE623C, 0xC5DE26FC, 0xB492C4BD, 0x59C00834, 0x4D46161F, 0x39C94516, 0x2101536D},
	{0x57792F65, 0xA9DC5D1F, 0x23C755E5, 0x4D4315CA, 0xA11C6DB5, 0x9EC58B4D, 0xAA63CD2D, 0x1379B2A2},
	0}, };
		static const byte var_key_exp[] = {0x3A, 0x83, 0x32, 0x52, 0x1F, 0xC9, 0x4C, 0x27, 0xB1, 0xBC, 0x11, 0x38, 0x22, 0xCC, 0xDF, 0xB2};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 960 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xDECFC079, 0x0C044A9C, 0x5C0504D7, 0x234F0724, 0x2D914305, 0xF421037F, 0xBF3F3017, 0x0B19862B},
	{0x32CE2FBF, 0x1E75151D, 0xD0EF419A, 0x95D8568E, 0x91B9CB19, 0xCEE93425, 0x6ABDCA22, 0x1A5DF2FD},
	0},
	{{0x663F3493, 0x3173AE05, 0x29F6E81F, 0xB3CDC88D, 0x9E3EABBA, 0x1BA09D42, 0x8BCBD812, 0x159FCAFE},
	{0x74831474, 0xBFC2ED74, 0x4393C6E5, 0x8EAFAB19, 0xBCA4CE69, 0x80D45FA5, 0xC4EDD5EA, 0x0E9D400D},
	0}, };
		static const byte var_key_exp[] = {0xF3, 0x0C, 0xC2, 0xAC, 0x5B, 0x43, 0xE0, 0x51, 0x8A, 0x7C, 0x44, 0x67, 0xB6, 0xA4, 0x4F, 0x70};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 961 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x6BCB047B, 0x6E313892, 0x233CAD3A, 0x3AAF986D, 0xCCC71611, 0x8EBF60EA, 0xCD4B9F52, 0x13D19F5C},
	{0x2867D317, 0xB67E8934, 0xBAC06348, 0x8283C51E, 0x5B7D01EA, 0x59EE3F06, 0x0EF2CFF8, 0x250248D5},
	0},
	{{0xB88A73AF, 0x364333BA, 0xF8D4BF46, 0x85DE8A33, 0xD9029168, 0x288E51E4, 0xDB279B89, 0x1BC82505},
	{0x851EBB69, 0x45DF23AB, 0xF4425CCB, 0x8FEEA54A, 0xDAD096E6, 0xA04FD3DA, 0x4D01299A, 0x0B885740},
	0}, };
		static const byte var_key_exp[] = {0xA1, 0x9A, 0x4A, 0xB9, 0x50, 0xA5, 0x0E, 0x5B, 0x4B, 0xF8, 0x2B, 0x31, 0x2D, 0xEB, 0xAE, 0xFB};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 962 key");
	}
	{

		static bbkem_ciphertext var_cipher = {{{0x7bdcc13d, 0xbc1e4151, 0x2052e76a, 0x47e1a39, 0x8a2a901, 0xaee0ec4f, 0x8e6ce519, 0x2385c738}, {0xdf686823, 0x1d71439f, 0x138c6be4, 0x2bb5c21f, 0x59887a06, 0xe76f3498, 0x7255911b, 0x1e45cdb8}, 0x0},
		{{0x1c51451e, 0x72bd2311, 0x7a7c09fe, 0xa555ae71, 0xe8b94753, 0x796660ae, 0xe33eaed0, 0x20cbe8df}, {0x86e8b372, 0x4a9d2f8f, 0x491c4bbe, 0x10e2c483, 0xd11d2741, 0xc078d64e, 0x85de294d, 0x1ef69976}, 0x0}};
		static const char *var_id = "cm0 in public";
		static const byte var_key_exp[] = {0x7b, 0x4b, 0x88, 0x44, 0x6f, 0x1c, 0x24, 0xbd, 0x2a, 0x8a, 0x32, 0x99, 0x4b, 0x12, 0xc6, 0x5c};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 962 key");
	}
#endif
#elif (BNCURVE == BN158)
#ifdef MONTGOMERY_ARITHMETIC
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xB981842E, 0x46F6F360, 0x6ABFA614, 0x54B4A322, 0x153F05E8},
	{0x48BC6394, 0x2F435562, 0x807FA061, 0xDAEE3467, 0x01127CE4},
	0},
	{{0x3BDD2FB4, 0x82D3CD32, 0xDDD15BEA, 0x657002FB, 0x14194F65},
	{0x96F2DCF9, 0x386D8152, 0x4674C8A4, 0x28B99DF7, 0x16167C0B},
	0}, };
		static const byte var_key_exp[] = {0x57, 0x2E, 0x0B, 0xB6, 0x52, 0xD7, 0x8E, 0x31, 0x1E, 0x90, 0x72, 0x70, 0xEE, 0x8D, 0xAD, 0x3E};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 947 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x3FDF661F, 0x91197F9C, 0xCF88EE9D, 0x211C3E39, 0x004EF517},
	{0xF76805E6, 0x3486A5D2, 0x3530EB0C, 0xA1C601EA, 0x156FBB95},
	0},
	{{0x8098B305, 0x0AAD78EC, 0x36AB280B, 0x790E4E84, 0x06E17008},
	{0xDB3910E8, 0xD249E82F, 0x8EB7312B, 0xFC0BC057, 0x15F1126E},
	0}, };
		static const byte var_key_exp[] = {0xAB, 0x05, 0xEC, 0x6E, 0x37, 0x6E, 0xDF, 0x8C, 0xF2, 0x24, 0xE6, 0x5A, 0x9E, 0xDA, 0x9C, 0xB5};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 948 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xEF1F3530, 0xAF56BA5F, 0xDBC950B4, 0xB71D04EF, 0x1154A4C1},
	{0xAF8471A4, 0x9DE711BF, 0x31A154E0, 0x3108E39E, 0x22C01206},
	0},
	{{0x901EABAE, 0x7069BA08, 0x3F025338, 0xE87EC30C, 0x1EB0DF0F},
	{0x62A1CF5D, 0xAF223A0B, 0x3F40A562, 0x41C9D1AB, 0x163C6E89},
	0}, };
		static const byte var_key_exp[] = {0x6A, 0x64, 0xC8, 0xD5, 0x45, 0xEB, 0x79, 0x4B, 0x23, 0x65, 0x6D, 0xD6, 0x2D, 0x9A, 0xDA, 0x96};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 949 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xDE9E6053, 0x3B86FABC, 0xEB98BE1D, 0xD7DB6688, 0x011FFB29},
	{0x356052D6, 0x2680D80B, 0x37B79BB7, 0xD2C3F64A, 0x07EA0B33},
	0},
	{{0x7B06F672, 0xE91C1126, 0x04A20367, 0x1F333CE7, 0x106DBE91},
	{0x993AAAF7, 0x22A704D7, 0x17D2FCB0, 0x969ADF3C, 0x1C56721C},
	0}, };
		static const byte var_key_exp[] = {0x53, 0x1A, 0x93, 0x1C, 0xCE, 0x16, 0x2A, 0xC1, 0x5C, 0x01, 0x21, 0x58, 0xE1, 0x32, 0xBF, 0x35};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 950 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x22333A8D, 0x7BA8026E, 0x0EA43CE6, 0x17009E93, 0x1D9AA942},
	{0x8DAA253B, 0x289AE2BB, 0xE92C79AB, 0x8228A502, 0x180D63AC},
	0},
	{{0x0D417459, 0x55388C56, 0x4E0F577D, 0x1F87824D, 0x1EBB93BA},
	{0x49CC66A7, 0x868CE844, 0x0B2A9C4B, 0x30B68EEC, 0x0AC53961},
	0}, };
		static const byte var_key_exp[] = {0x00, 0xD4, 0x38, 0xA9, 0x9E, 0x19, 0x56, 0x27, 0x0E, 0x79, 0xBB, 0xE6, 0x29, 0x50, 0x7F, 0x7D};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 951 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xB2623ED7, 0xB5663427, 0x947C5DCE, 0xC6DF06B7, 0x1EE300DA},
	{0xCEA39ECA, 0x71BC54A0, 0xC6C9B2AF, 0xF7781214, 0x02D58FC2},
	0},
	{{0xBC2C5F18, 0x1E8570CC, 0xC1E0F4C6, 0xC02A1566, 0x21AD325B},
	{0x30608348, 0x543A6987, 0xF1CBB55B, 0x60C456F1, 0x133674C1},
	0}, };
		static const byte var_key_exp[] = {0x20, 0x54, 0x41, 0x9C, 0xB4, 0xDD, 0x3B, 0x71, 0x0D, 0x53, 0xF6, 0x45, 0x5E, 0x34, 0x1B, 0xD7};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 952 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xB598CD3D, 0xD08F9304, 0x3C27445A, 0x464CA5B5, 0x0C72C621},
	{0x714ED207, 0x54E13F89, 0xE4F96B94, 0xFEF6237A, 0x2129273E},
	0},
	{{0x3A63F788, 0xF5F80D13, 0x1984DF35, 0x18B38508, 0x18D4A291},
	{0xE6123052, 0x5B9F4E15, 0x51E45D71, 0xE0E9C5AA, 0x14EBFAC2},
	0}, };
		static const byte var_key_exp[] = {0x32, 0x47, 0x1B, 0xC7, 0xAE, 0x5C, 0x15, 0x70, 0x71, 0xA5, 0x81, 0x94, 0x9F, 0xA3, 0x8F, 0x97};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 953 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xA0DA1440, 0xA59AC536, 0xC9EFF654, 0x4D8BD894, 0x23D51972},
	{0x97299891, 0x72743C7C, 0xE548BE06, 0x8921642B, 0x139B06CF},
	0},
	{{0x10775411, 0x206FC8F7, 0x4A767D1A, 0x3E712497, 0x05BE602A},
	{0x0475AECC, 0xAC5EBE44, 0x99022078, 0xC3005746, 0x01CAD826},
	0}, };
		static const byte var_key_exp[] = {0x75, 0x99, 0x44, 0x2C, 0xBF, 0xE7, 0xAC, 0x8D, 0x64, 0xFD, 0x84, 0xD1, 0x5E, 0x44, 0x8B, 0xE7};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 954 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xA0D28957, 0x2C8DD919, 0x0039B854, 0xC8AB7A8E, 0x0C774EE2},
	{0x0DB802E3, 0x21FD6585, 0x4104A9F5, 0x995CB6CD, 0x2020ED07},
	0},
	{{0xF24DA365, 0xE887C5BE, 0xBE4A6B5D, 0xC7552D23, 0x0D274784},
	{0x162A7FBD, 0xE4058B83, 0xA50EF257, 0x165904C3, 0x1E511D4A},
	0}, };
		static const byte var_key_exp[] = {0x9E, 0xF6, 0xEA, 0xC5, 0xF1, 0x97, 0xDC, 0x6C, 0xB0, 0xB7, 0xFC, 0xEE, 0xA7, 0x9E, 0x3B, 0xD3};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 955 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xDD11BF88, 0xDD87FF94, 0x3BE4C62D, 0x5807FD31, 0x09D5CF6E},
	{0x8F7D19EF, 0x95CF01E4, 0x6B19FE80, 0x176C9979, 0x02AB6F55},
	0},
	{{0x96E8FAE1, 0xC4EC96A4, 0x00704ABA, 0x0BD090E4, 0x18C1854D},
	{0x71D0ED55, 0x1B13323D, 0x420143B6, 0xE92A64F0, 0x116D87AF},
	0}, };
		static const byte var_key_exp[] = {0x79, 0x8A, 0x6B, 0xBE, 0xD4, 0x6D, 0x0B, 0x2D, 0x5F, 0xB5, 0x67, 0xD9, 0x63, 0x38, 0xB7, 0x32};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 956 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xBA0D8C24, 0xAA77D0E5, 0xEAD0B98C, 0x78107F4B, 0x132B8D2D},
	{0x49E3E02F, 0x1D0AABF0, 0xA6D55961, 0x5D6A6784, 0x13443A14},
	0},
	{{0x91E5BBDB, 0x6C77FFB7, 0x235918CE, 0xB569A525, 0x17C1F922},
	{0x715570F8, 0x637A4C06, 0xE2D3D4CB, 0xCBD77F62, 0x1246C7A3},
	0}, };
		static const byte var_key_exp[] = {0x4A, 0x1C, 0x7B, 0xE0, 0x6F, 0x35, 0xAE, 0xB2, 0xAF, 0xBA, 0x62, 0x67, 0x39, 0x81, 0x00, 0x7E};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 957 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xD1A1B93F, 0xF09E2393, 0xEA8C69C5, 0x13646144, 0x12E818F7},
	{0x19F95D65, 0xD24A4694, 0x606CF6DF, 0xFDCB263D, 0x08A97BD7},
	0},
	{{0xEEEBEDBC, 0x47DA8A7B, 0x448F195D, 0x2B27E9C0, 0x051758A1},
	{0x4D92FD55, 0x72EF603E, 0x4BD4E439, 0xBDB09100, 0x08A1A3F4},
	0}, };
		static const byte var_key_exp[] = {0x15, 0x6C, 0x1B, 0x12, 0xCD, 0x75, 0xE5, 0xFA, 0x15, 0xF9, 0x21, 0x13, 0x47, 0x9D, 0x58, 0xA0};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 958 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x1C592D14, 0x16D4AA10, 0x6FF1FE3F, 0xA5B354D1, 0x1AA895AC},
	{0x62D34D7B, 0x54010991, 0x381E53CE, 0x5F4575E8, 0x2252DA88},
	0},
	{{0xDF8D0A9A, 0x7CB97050, 0x2C73CEF0, 0x473D37A8, 0x18F40CA1},
	{0x41AAB023, 0x793DDB56, 0x4B92E855, 0x21229E27, 0x0BE960D7},
	0}, };
		static const byte var_key_exp[] = {0x5D, 0x71, 0xF0, 0x69, 0x47, 0x1C, 0x40, 0x6A, 0x74, 0x1E, 0xDB, 0x9A, 0x8D, 0x8F, 0xF7, 0x25};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 959 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0xB48B7DC5, 0xA94211E5, 0x196CEC54, 0xF3ECCC4F, 0x224B65D3},
	{0xA643A5DA, 0x030FD270, 0xBD530373, 0xD6153C5C, 0x22325888},
	0},
	{{0x5A754650, 0xEA6C8D9F, 0xD09305BD, 0x0DB4AF87, 0x1C34FD48},
	{0xF1BCCF17, 0x7C4AA5B0, 0x9B308FB8, 0xF21175C3, 0x1B7DF981},
	0}, };
		static const byte var_key_exp[] = {0x14, 0xB9, 0x8A, 0xAC, 0x0A, 0x22, 0x98, 0xE1, 0x95, 0xF7, 0x9E, 0x8E, 0xA7, 0x63, 0xB2, 0x3A};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 960 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x806CCA1F, 0x178AAE41, 0xC8CABF64, 0x9E69BEBA, 0x0CC5F303},
	{0x08864FCA, 0x0E2C345E, 0x29BC5EB1, 0x5B056582, 0x015494A4},
	0},
	{{0x1D3EAD0B, 0x26B8C2BC, 0x6E8656C5, 0x4385A30C, 0x11E79BCB},
	{0xFCAAFE63, 0x2380064D, 0xEDA82603, 0x9529EC8A, 0x1AB7A2E9},
	0}, };
		static const byte var_key_exp[] = {0xB0, 0x96, 0x1D, 0xD1, 0xD2, 0xED, 0x79, 0xF9, 0xB6, 0x70, 0x71, 0xE3, 0xD4, 0xAD, 0x58, 0x95};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 961 key");
	}
	{
		static const char *var_id = "cm0 in public";
		static bbkem_ciphertext var_cipher = { {{0x8B2C3285, 0x68BAC1B8, 0x98F39FF0, 0x8FC9DB71, 0x1BEEA685},
	{0xB3C7FEAF, 0xCFA9CB49, 0x0AB46B8B, 0x857E8520, 0x1B98C19F},
	0},
	{{0xA75173D3, 0xE2637194, 0xC7E7B916, 0x3BE0A14B, 0x216077A6},
	{0xC3F2B241, 0x4497BAC1, 0xDE51B3E3, 0xE504F1E9, 0x02B426D7},
	0}, };
		static const byte var_key_exp[] = {0x5D, 0x02, 0x5E, 0xA7, 0xF0, 0x39, 0x2E, 0x60, 0x99, 0xF7, 0xC5, 0xEE, 0x67, 0x33, 0xE0, 0x49};
		decapsulate_key(var_key, &var_cipher, var_id);
		assert_bytearr_equal(var_key_exp, var_key, 16, "decapsulate_key 962 key");
	}
#endif
#endif
}
